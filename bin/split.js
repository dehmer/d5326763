const isType = name => R.propEq(name, 'type')
const verbatim = node => [node]

const split = R.cond([
  [isType('File'), ({ program, ...rest}) => [rest, program]],

  // Import
  [isType('ImportDeclaration'), ({ specifiers, ...rest }) => [rest, specifiers]],
  [isType('ImportSpecifier'), ({ imported, local, ...rest }) => [rest, imported, local]],
  [isType('ImportDefaultSpecifier'), ({ local, ...rest }) => [rest, local]],
  [isType('ImportNamespaceSpecifier'), ({ local, ...rest }) => [rest, local]],

  // Export
  [isType('ExportNamedDeclaration'), ({ declaration, specifiers, ...rest }) => [rest, declaration, specifiers]],
  [isType('ExportDefaultDeclaration'), ({ declaration, ...rest }) => [rest, declaration]],
  // TODO: ExportAllDeclaration
  [isType('ExportSpecifier'), ({ local, exported, ...rest }) => [rest, local, exported]],

  [isType('Program'), ({ body, ...rest}) => [rest, body]],
  [isType('FunctionDeclaration'), ({ id, params, body, ...rest }) => [rest, body]],
  [isType('BlockStatement'), ({ body, ...rest }) => [rest, body]],
  [isType('IfStatement'), ({ test, consequent, alternate, ...rest }) => [rest, test, consequent, alternate]],
  [isType('BinaryExpression'), ({ left, right, ...rest }) => [rest, left, right]],
  [isType('Identifier'), verbatim],
  [isType('ExpressionStatement'), ({ expression, ...rest}) => [rest, expression]],
  [isType('CallExpression'), ({ callee, arguments, ...rest}) => [rest, callee, arguments]],
  [isType('MemberExpression'), ({ object, property, ...rest}) => [rest, object, property]],
  [isType('NullLiteral'), verbatim],
  [isType('NumericLiteral'), verbatim],
  [isType('BooleanLiteral'), verbatim],
  [isType('StringLiteral'), verbatim],
  [isType('RegExpLiteral'), verbatim],
  [isType('ReturnStatement'), ({ argument, ...rest }) => [rest, argument]],
  [isType('CommentBlock'), verbatim],
  [isType('VariableDeclaration'), ({ declarations, ...rest }) => [rest, declarations]],
  [isType('VariableDeclarator'), ({ id, init, ...rest }) => [rest, id, init]],
  [isType('ForStatement'), ({ init, test, update, body, ...rest }) => [rest, init, test, update, body]],
  [isType('UpdateExpression'), ({ argument, ...rest }) => [rest, argument]],
  [isType('ClassDeclaration'), ({ id, superClass, body, ...rest }) => [rest, id, superClass, body]],
  [isType('ClassBody'), ({ body, ...rest }) => [rest, body]],
  [isType('ClassMethod'), ({ key, params, body, ...rest }) => [rest, key, params, body]],
  [isType('Super'), verbatim],
  [isType('AssignmentExpression'), ({ left, right, ...rest }) => [rest, left, right]],
  [isType('LogicalExpression'), ({ left, right, ...rest }) => [rest, left, right]],
  [isType('ObjectExpression'), ({ properties, ...rest }) => [rest, properties]],
  [isType('ThisExpression'), verbatim],
  [isType('ConditionalExpression'), ({ test, consequent, alternate, ...rest }) => [rest, test, consequent, alternate]],
  [isType('NewExpression'), ({ callee, arguments, ...rest }) => [rest, callee, arguments]],
  [isType('ArrowFunctionExpression'), ({ params, body, ...rest }) => [rest, params, body]],
  [isType('ObjectProperty'), ({ key, value, ...rest }) => [rest, key, value]],
  [isType('ArrayExpression'), ({ elements, ...rest }) => [rest, elements]],
  [isType('UnaryExpression'), ({ argument, ...rest }) => [rest, argument]],
  [isType('FunctionExpression'), ({ params, body, ...rest }) => [rest, params, body]],
  [isType('ContinueStatement'), verbatim],
  [isType('BreakStatement'), verbatim],
  [isType('CommentLine'), verbatim],
  [isType('ForInStatement'), ({ left, right, body, ...rest }) => [rest, left, right, body]],
  [isType('SequenceExpression'), ({ expressions, ...rest }) => [rest, expressions]],
  [isType('TryStatement'), ({ block, handler, finalizer, ...rest }) => [rest, block, handler, finalizer]],
  [isType('CatchClause'), ({ param, body, ...rest }) => [rest, param, body]],
  [isType('ThrowStatement'), ({ argument, ...rest }) => [rest, argument]],
  [isType('ArrayPattern'), ({ elements, ...rest }) => [rest, elements]],
  [isType('SwitchStatement'), ({ discriminant, cases, ...rest }) => [rest, discriminant, cases]],
  [isType('SwitchCase'), ({ consequent, test, ...rest }) => [rest, consequent, test]],
  [isType('WhileStatement'), ({ test, body, ...rest }) => [rest, test, body]],
  [isType('DoWhileStatement'), ({ test, body, ...rest }) => [rest, test, body]],
  [isType('SpreadElement'), ({ argument, ...rest }) => [rest, argument]],
  [isType('TemplateLiteral'), ({ expressions, quasis, ...rest }) => [rest, expressions, quasis]],
  [isType('TemplateElement'), verbatim],
  [isType('LabeledStatement'), ({ body, label, ...rest }) => [rest, body, label]],
  [isType('ObjectPattern'), ({ properties, ...rest }) => [rest, properties]],
  [isType('AwaitExpression'), ({ argument, ...rest }) => [rest, argument]],
  [isType('OptionalMemberExpression'), ({ object, property, ...rest }) => [rest, object, property]],
  [isType('AssignmentPattern'), ({ left, right, ...rest }) => [rest, left, right]],
  [isType('ForOfStatement'), ({ left, right, body, ...rest }) => [rest, left, right, body]],
  [R.T, R.always(undefined)]
])

module.exports = split